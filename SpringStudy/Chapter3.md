### 템플릿

3장에서 예외처리의 필요성과 객체지향 설계 원리 및 디자인 패턴, DI를 적용하는 방법을 살펴 보았다.

DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 예외처리를 반드시 지켜야한다. 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야하기 때문에 try/catch/finally 블록으로 관리해야 한다.

* 오류가 발생할 때마다 미처 반환되지 못한 커넥션이 계속 쌓이면 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서버가 중단될 수 있다.


try/catch/finally 구문의 문제점은 실수로 몇줄을 빼먹어도 테스트를 돌렸을 때 못 찾을 수 있고 서버에 배치 후에 커넥션 풀이 주기마다 꽉 차는 문제가 발생할 수 있는 점이다. 디자인 패턴을 적용해 해결해 볼 수 있다.(분리와 재사용)

책에서는 템플릿 메소드 패턴과 전략 패턴을 적용한다.

* 패턴을 적용하기 전에 변하는 성격이 다른 것을 찾아내는 것이 먼저다. 변하는 부분과 변하지 않는 부분으로 구분한다. **변하는 부분**은 각 메소드마다 로직에 따라 변하는 부분을 말하고 **변하지 않는 부분**은 비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않고 고정된 부분을 말한다.(책에서는 DB와 연결하고 close() 코드 블록이 변하지 않는 부분)

* 템플릿 메소드 패턴은 추출한 메소드를 추상 메소드로 선언으로 변경하고 클래스 또한 추상 클래스로 변경한다. 이를 상송하는 서브클래스를 만들어, 거기서 이 메소드를 구현한다. 따라서 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야한다는 제한이 있다. 또한 컴파일 시점에 이미 서브클래스들과 변하지 않는 코드를 가진 클래스의 코드블록과 관계가 결정되어 있어 유연성이 떨어진다.

* 전략 패턴은 Client가 전략을 생성해서 전략을 실행할 Context에게 주입하는 패턴이다. 행동 이름자체는 똑같지만 내용을 다르게 하기 위해서 사용된다.


#### JDBC 전략 패턴의 최적화

전략 클래스의 추가정보는 생성자를 통해 제공 받게 만들 수 있다.

 위의 방법으로 전략 패턴을 적용해서 만들어진 구조에 대한 문제점은 두가지가 있다. 첫 번재는 DAO 메소드마다 새로운 STatementsStrategy 구현 클래스를 만들어야한다는 점이다. 두 번째는 전략 클래스에 전달할 부가적인 정보가 있을 경우에 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 만들어야 한다는 점이다. 이를 해결할 수 있는 방법은 다음과 같다.

* 로컬 클래스: 클래스를 매번 독립된 파일로 만들지 않고 UsefDao 클래스 내부 클래스로 정의하면 클래스 파일이 많아지는 무제를 해결할 수 있다. 내부 클래스이기 때문에 자신을 선언한 메소드의 로컬 변수에 접근할 수 있다는 장점이 있다. 그래서 부가적인 정보를 생성자로 받을 필요가 사라진다.

* 익명 내부 클래스: 이름을 갖지 않는 클래스로 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어진다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다. 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.


#### 템플릿과 콜백

##### 템플릿/콜백 패턴

 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조다. 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 익명함수를 사용해서 Interface만 구현한 채 실제 로직을 구현하는 방식으로 Spring에서 DI 의존성 주입과 매우 유사하다.

* 템플릿은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다. 전략 패턴의 컨텍스트를 템플릿이라고 부른다. 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러번 호출할 수도 있다.

* 콜백은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다. 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다.

* 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.

* 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.

* 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플릿과 콜백을 제공한다.


***

정리해보면 좋을 것같은 내용을 따로 정리했다.


### 중첩 클래스

다른 클래스 내부에 정의되는 클래스이다.

* static class: 독립적으로 오브젝트로 만들어질 수 있는 클래스이다.

* inner class: 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 클래스이다. 밖에 있는 클래스는 내부 클래스를 멤버변수처럼 사용할 수 있으며 내부 클래스는 자신의 밖에 있는 클래스의 자원을 직접적으로 사용할 수 있다.

	* 멤버 내부 클래스: 멤버 필드처럼 오브젝트 레벨에 정의되는 클래스이다.
	* 로컬 클래스: 메소드 내부에 클래스를 정의하여 메소드 내의 지역변수처럼 사용한다. 메소드 밖에서 사용할 수 없다. => 지연 변수 범위와 동일
	* 익명 내부 클래스: 생성과 동시에 부모 클래스를 상속받아 내부에서 오버라이딩해서 사용한다. 선언된 위치에 따라서 범위가 다르다.


### 제네릭스

* 자바의 언어에 타입 파라미터라는 개념을 도입한 것 (?)

* 다양한 타입의 객체들을 다루는 메서드나 클래스에 컴파일 시의 타입체크를 해주는 기능이다. 컴파일 시에 타입체크를 진행하기 때문에 개발자가 의도한 타입이 들어간 것은 아닌지 사전에 알 수 있다.

* 제네릭스를 이용해 다양한 오브젝트 타입을 지원하는 인터페이스나 메소드를 정의할 수 있다.

``` java
ArrayList<String> list = new ArrayList<String>();
```


### JDBC

JDBC를 한번 정리해보았다.

* 정의

	* 자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약이다. 
	* 자바 프로그램내에서 SQL문을 실행하기 위한 자바 API
	* SQL 프로그래밍 언어의 통합 접근 중 한 형태이다. 

* JAVA는 표준 인터페이스인 JDBC API를 제공한다.

* 데이터베이스 벤더, 또는 기타 써드파티에서는 JDBC 인터페이스를 구현한 드라이버를 제공한다.
