# 5장 서비스 추상화

비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다. 비즈니스 로직 코드 또한 내부적으로 책이모가 역할에 따라서 깔끔하게 메소드로 정리돼야 한다.

서비스 계층: 뷰에서 엔티티에 직접 접근하지 않고 비즈니스 로직을 처리할 수 있도록하는 계층

* 핵심 비즈니스 로직 수행
* 비즈니스 로직: 서버에서 사용자의 요구사항 처리
* 예를 들면 사용자의 레벨을 업그레이드 하는 작업


![image](https://user-images.githubusercontent.com/48270067/148324439-71fa5e5b-08b9-483a-8d6f-a2e7828a970f.png)



---

## 트랜잭션

모든 사용자에 대한 레벨 업그레이드 작업은 새로 추가된 기술 요구사항대로 전체가 다 성공하든지 아니면 전체가 다 실패하든지 해야한다. 더이상 쪼개질 수 없는 작업임.
따라서 중간에 예외가 발생해서 작업을 완료할 수 없다면 아에 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야한다. 이것이 바로 트랜잭션이다.

트랜잭션이란 더이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성의 원자성을 의미한다.


#### 트랜잭션 경계 설정

여러 사용자에 대한 레벨 수정 작업 등 여러개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야하는 경우도 있다.
두개의 SQL이 필요한 경우에 이 두가지 작업이 하나의 트랜잭션이 되려면 두번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우에는 앞에서 처리한 SQL 작업도 취소시켜야한다.

* 트랜잭션 롤백 : 취소 작업
* 트랜잭션 커밋 : 성공적으로 마무리된 것을 DB에 알려 작업을 확정


#### 트랜잭션 경계 설정 구조

```java
public void method() throws Exception {
	(1) DB connection 생성
    	(2) 트랜잭션 시작
    try {
    	(3) insert 나 update.. 등 DB 관련 작업
        (4) 트랜잭션 커밋
    } catch(Exception e) {
    	(5) 트랜잭션 롤백
    } finally {
    	(6) DB connection 종료
    }
}
```

위의 구조에서는 하나의 connection으로 진행되어야한다. 하지만 connection 객체를 공유하려고 파라미터로 전달해주는 코드는 트랜잭션 문제는 해결할 수 있지만 JdbcTemplate을 더이상 활용할 수 없다.

스프링은 트랜잭션 동기화를 통해 해결 방법을 제공해준다.


#### 트랜잭션 동기화

어떤 서비스 로직에서 트랜잭션을 시작하기 위해 만든 connection 오브젝트를 특별한 저장소에 보관해두고, 이후에 호출되는 로젝에서 저장된 connection을 가져다가 사용하게 하는 것이다.

트랜잭션 동기화 저장소는 작업 쓰레드마다 connection 객체를 독립적으로 관리하기 때문에, 멀티 쓰레드 환경에서도 충돌이 발생할 여지가 없다. 

스프링에서는 DataSourceUtils.getConnection(dataSource)라는 DB 커넥션 생성과 동기화를 함께 해주는 유틸리티 메서드를 제공한다.

#### 트랜잭션 서비스 추상화

하나의 트랜잭션 안에 여러 개의 DB에 데이터를 넣는 작업을 해야할 필요가 발생했을 때 로컬 트랜잭션으로는 불가능하다. 왜냐하면 로컬 트랜잭션은 하나의 DB에 종속되기 때문이다.

별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 글로벌 트랜잭션 방식을 사용해야한다.

트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다.

트랜잭션 동기화에서 사용한 DataSourceUtils.getConnection(dataSource) 의 코드를 사용하게 된다면 JDBC API에 의존적인 코드가 되어버린다. 여러 기술의 사용 방법에 공통점이 있다면 추상화를 생각해볼 수 있다.

* 추상화 : 하위 시스템의 공통점을 뽑아내서 분리 시키는 것을 말한다.

스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다.

* 트랜잭션 기술의 공통점을 담고 있음
* 종속적인 코드를 이용하지 않고도 일관되게 트랜잭션을 처리할 수 있다.

![image](https://user-images.githubusercontent.com/48270067/148326852-7502c68e-ec11-4ddc-ab98-4067c6b2a4a7.png)


## 서비스 추상화와 단일 책임 원칙

#### 단일 책임 원칙

단일책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 것을 의미한다.

하나의 모듈이 바뀌는 이유는 한가지여야한다

인터페이스 도입하고 이를 DI로 연결해야한다.

#### 단일 책임 원칙의 장점

단일 책임 원칙을 잘 지키고 있다면,

* 어떤 변경이 필요할 때 수정 대상이 명확해진다.
* 결합도가 낮아져 서로의 변경이 영향을 주지 않는다.
* 테스트하기 편해진다. (테스트 대상이 되는 코드를 수정하지 않고, 유연하게 변경이 가능하여 테스트에도 편리하다)

#### 서비스 추상화

트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.

* 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입
* 테스트하기 어려운 JavaMail 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.

## 테스트 대역

테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다. 테스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.

* 목 오브젝트: 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고 한다.














---

스프링이 제공하는 트랜잭션 핵심 기술

1. 트랜잭션 동기화
2. 트랜잭션 추상화
3. AOP를 이용한 트랜잭션 분리
