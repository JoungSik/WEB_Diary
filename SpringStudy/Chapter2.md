## 2. 테스트

저자가 생각하는 스프링이 개발자에게 제공하는 가장 중요한 가치


* 객체지향
	* 애플리케이션은 계속 변하고 복잡해진다. 확장과 변화를 고려한 객체지향적 설계 & 그것을 효과적으로 담아낼 수 있는 Ioc/DI 같은 기술로 대응할 수 있다.

* 테스트 : 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 줌



  
***
  



#### 테스트


* 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서, 만든 코드를 확신할 수 있게 해주는 작업


* 코드나 설계에 결함을 찾을 수 있음


* 대상과 조건이 간단하고 명확할 수록 좋다 => 작은 단위로 제한해서 테스트하는 것이 편리 == **단위테스트**
	* 단위 테스트 : 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서 사용


* 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요 => 자주 반복 가능
	* 수동 확인 작업의 번거로움 + 실행 작업의 번거로움 =해결=> 테스트 검증의 자동화


* 테스트는 수정 후 개발자에게 안심을 준다


* main 메소드 테스트는 프레임워크에 적용하기엔 직접 제어권을 갖기 때문에 부적합하다. ==> JUnit


#### JUnit


자바의 표준 테스팅 프레임워크


* 프레임워크 (=> 제어의 역전을 알고 JUnit을 보니까 다른 느낌이다.)

	* 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다. 따라서 프레임워크에서 동작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.


* JUnit => public 선언 + @Test 애노테이션 필요


* 매처라고 불리는 조건


* JUnit => IDE의 지원을 받는 것이 가장 편리하다. 그런데 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때도 있다. 이런 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행하는 것이 좋다. 이때는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하면 된다.


* 단위테스트는 항상 일관성 있는 결과가 보장돼야 한다: 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 함


* @Test(expected) expected를 추가하면 보통의 테스트와는 반대로, 정상적으로 테스트 메소드를 마치면 테스트가 실패하고 지정한 예외가 던져지면 테스트가 성공한다.

	* 예외가 반드시 발생해야 하는 경우를 테스트하고 싶을 때 사용



***




#### TDD


개발자가 테스트를 직접 만들 때 자주 하는 실수는 성공하는 테스트만 골라서 만드는 것이다. 그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

=> 이런 구체적인 개발 전략 : **TDD 테스트 주도 개발**


기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수 있다.
이처럼 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 **테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법이 테스트 주도 개발**이다.


* 피드백을 매우 빠르게 받을 수 있고 매번 테스트가 성공하는 것을 보면서 작성한 코드에 대한 확신을 가질 수 있다.


* 장점

	* 코드를 만들어 테스트를 실행하는 간격이 매우 짧다  =>  테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면, 오류가 발생했을 때 원인을 찾기가 쉽지 않다.


* 테스트코드도 리팩토링의 대상이다.





#### JUnit 프레임워크의 기능


* @Before: @Test 메소드가 실행되기 전에 먼저 실행 돼야 하는 메소드를 정의한다.  <= 테스트를 실행할 때마다 반복되는 준비 작업 코드 처리


* JUnit 프레임워크의 동작과정


	1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
	2. 테스트 클래스의 오브젝트를 하나 만든다.
	3. @Before가 붙은 메소드가 있으면 실행한다.
	4. @Test가 붙은 메소드를 하나 호출하고 테스트 겨로가를 저장해둔다.
	5. @After가 붙은 메소드가 있으면 실행한다.
	6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
	7. 모든 테스트의 결과를 종합해서 돌려준다.


* @Before, @After 메소드를 테스트 메소드에서 직접 호출하지 않기 때문에 서로 주고받을 정보나 오브젝트가 있다면 인스턴스 변수를 이용해야 함


* 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다

	* 왜? 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해


* 테스트 메소드의 일부에서만 공통적으로 사용되는 코드가 있다면 @Before를 사용하기보다는 일반적인 메소드 추출방법을 써서 메소드를 분리하고 테스트 메소드에서 직접 호출해 사용하도록 만드는 편이 낫다.




***



픽스처(fixture): 테스트를 수행하는 데 필요한 정보나 오브젝트

* 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다.





#### 애플리케이션 컨텍스트 생성방식의 문제

@Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 세 번 만들어진다.


* 시간이 오래 걸림( 애플리케이션 컨텍스트가 만들어질 때 모든 싱글톤 빈 오브젝트를 초기화하는데 이때 시간이 많이 걸릴 수 있다.)


* 애플리케이션 컨텍스트가 초기화 될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다. 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다. (?)


* (시간과 자원이 소모되는) 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다. 하지만 JUnit이 매번 테스트 클래스의 오브젝트를 새로 만들기 때문에 여러 테스트가 함께 참조할 애플리케이션 컨텍스트를 오브젝트 레벨에 저장해 두면 곤란함


	* (문제의 해결법)스프링이 직접 제공하는 **애플리케이션 컨텍스트 테스트 지원 기능**을 사용하자!




#### 스프링 테스트 컨텍스트 프레임워크

* @Autowired, @RunWith(스프링의 테스트 컨텍스트 프레임워크의 Junit 확장기능 지정), @ContextConfiguration(테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정) 사용


* Private ApplicationContext context: 테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값이 주입된다. 스프링의 Junit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다.


* 스프링이 애플리케이션 컨텍스트가 한 번만 만들어서 공유하게 해줬기 때문에 수행 속도가 발라진다.


* 스프링 테스트 컨텍스트 프레임워크의 기능

	* 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것

	* 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.




#### @Autowired: 스프링의 DI에 사용되는 애노테이션


* 이 애노테이션이 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 인스턴스 변수에 주입해준다. 메소드가 없이도 주입이 가능하다.


* 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있다. (자동와이어링)


* 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.


* 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록함




***




#### 인터페이스를 두고 DI를 적용해야하는 이유


* 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다.


* 클래스 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다.


* 테스트 : DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다.




#### **테스트**에 DI를 이용하는 방법


1. DI를 이용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주는 방법

	*  장점: XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다.
	*  주의할 점: 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않은 것이 원칙이나 이 방법은 의존관계를 강제로 변경하기 때문에 바람직하지 않다.다. 그래서 **@DirtiesContext 애노테이션**을 추가해 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. (그래도 찜찜)


2. 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법
	* 두 가지 종류의 설정파일을 만들어서 하나는 서버에서 운영용으로 사용할 DataSource를 빈으로 등록해두고, 다른 하나에는 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되게 만드는 것


3. 스프링 컨테이너를 사용하지 않고 테스트를 만드는 방법
	* 테스트에서 직접 오브젝트를 만들고 DI 해서 사용해도 된다.
	* 단점: Junit은 매번 새로운 테스트 오브젝트를 만들기 때문에 매번 새로운 UserDao 오브젝트가 만들어짐
	* DI를 위해 컨테이너가 반드시 필요한 것은 아니다. 컨테이너가 DI를 가능하게 해주는 것은 아니다.


* 어떤 방법을 택해야할까?
	* 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려!
	* 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우가 있다면 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다. + 테스트 전용 설정파일을 따로 만들어 사용
	* 예외적인 의존관계를 강제로 구성해서 테스트해얗할 경우에는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트 하는 방법을 사용 + @DirtiesContext 애노테이션 사용




***




#### 학습테스트


자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서 작성하는 테스트


* 목적
	* 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것


* 장점
	* 다양한 조건에 따른 기능을 손쉽게 확인할 수 있다.
	* 학습 테스트 코드를 개발 중에 참고할 수 있다.
	* 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
	* 테스트 작성에 대한 좋은 훈련이 된다.
	* 새로운 기술을 공부하는 과정이 즐거워진다.




#### 버그테스트

코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.


* 버그테스트는 일단 실패하도록 만들어야함


* 장점
	* 테스트의 완성도를 높여준다.
	* 버그의 내용을 명확하게 분석하게 해준다.
	* 기술적인 문제를 해결하는데 도움이 된다.
